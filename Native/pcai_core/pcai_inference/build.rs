use std::env;
use std::fs;
use std::path::Path;
use std::process::Command;

fn main() {
    // Detect CUDA installation
    if env::var("CUDA_PATH").is_ok() || env::var("CUDA_HOME").is_ok() {
        println!("cargo:rustc-cfg=has_cuda");
        println!("cargo:rerun-if-env-changed=CUDA_PATH");
        println!("cargo:rerun-if-env-changed=CUDA_HOME");
    }

    // Generate version information
    generate_version_info();

    // Rerun build script if these change
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=.git/HEAD");
    println!("cargo:rerun-if-changed=.git/index");
    println!("cargo:rerun-if-env-changed=PCAI_VERSION");
    println!("cargo:rerun-if-env-changed=PCAI_GIT_HASH");
    println!("cargo:rerun-if-env-changed=PCAI_BUILD_TIMESTAMP");
}

fn generate_version_info() {
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("build_info.rs");

    // Try to get version from environment (set by Build.ps1)
    let version = env::var("PCAI_VERSION")
        .or_else(|_| env::var("PCAI_BUILD_VERSION"))
        .unwrap_or_else(|_| get_version_from_git());

    let semver = env::var("PCAI_SEMVER").unwrap_or_else(|_| "0.1.0".to_string());

    let git_hash = env::var("PCAI_GIT_HASH").unwrap_or_else(|_| get_git_hash());

    let git_hash_short = env::var("PCAI_GIT_HASH_SHORT").unwrap_or_else(|_| {
        if git_hash.len() >= 7 {
            git_hash[..7].to_string()
        } else {
            git_hash.clone()
        }
    });

    let git_branch = env::var("PCAI_GIT_BRANCH").unwrap_or_else(|_| get_git_branch());

    let build_timestamp = env::var("PCAI_BUILD_TIMESTAMP").unwrap_or_else(|_| {
        chrono::Utc::now().format("%Y-%m-%dT%H:%M:%SZ").to_string()
    });

    let build_type = env::var("PCAI_BUILD_TYPE").unwrap_or_else(|_| "dev".to_string());

    let target = env::var("TARGET").unwrap_or_else(|_| "unknown".to_string());
    let profile = env::var("PROFILE").unwrap_or_else(|_| "unknown".to_string());

    // Detect features
    let mut features = Vec::new();
    if env::var("CARGO_FEATURE_LLAMACPP").is_ok() {
        features.push("llamacpp");
    }
    if env::var("CARGO_FEATURE_MISTRALRS_BACKEND").is_ok() {
        features.push("mistralrs");
    }
    if env::var("CARGO_FEATURE_CUDA_LLAMACPP").is_ok() {
        features.push("cuda-llamacpp");
    }
    if env::var("CARGO_FEATURE_CUDA_MISTRALRS").is_ok() {
        features.push("cuda-mistralrs");
    }
    if env::var("CARGO_FEATURE_SERVER").is_ok() {
        features.push("server");
    }
    if env::var("CARGO_FEATURE_FFI").is_ok() {
        features.push("ffi");
    }
    let features_str = features.join(",");

    // Check for CUDA
    let has_cuda = env::var("CUDA_PATH").is_ok() || env::var("CUDA_HOME").is_ok();
    let cuda_version = if has_cuda {
        get_cuda_version()
    } else {
        "none".to_string()
    };

    // Generate Rust source file with build info
    let content = format!(
        r#"//! Auto-generated build information. Do not edit.
//! Generated by build.rs at compile time.

/// Full version string (semver + commits + hash)
pub const VERSION: &str = "{version}";

/// Semantic version only
pub const SEMVER: &str = "{semver}";

/// Full git commit hash
pub const GIT_HASH: &str = "{git_hash}";

/// Short git commit hash (7 chars)
pub const GIT_HASH_SHORT: &str = "{git_hash_short}";

/// Git branch name
pub const GIT_BRANCH: &str = "{git_branch}";

/// Build timestamp (ISO 8601 UTC)
pub const BUILD_TIMESTAMP: &str = "{build_timestamp}";

/// Build type: release, prerelease, or dev
pub const BUILD_TYPE: &str = "{build_type}";

/// Compilation target triple
pub const TARGET: &str = "{target}";

/// Build profile (debug/release)
pub const PROFILE: &str = "{profile}";

/// Enabled features
pub const FEATURES: &str = "{features_str}";

/// CUDA version (if available)
pub const CUDA_VERSION: &str = "{cuda_version}";

/// Whether CUDA is available
pub const HAS_CUDA: bool = {has_cuda};

/// Null-terminated version for FFI
pub const VERSION_CSTR: &[u8] = b"{version}\0";

/// Build info as a formatted string
pub fn build_info() -> String {{
    format!(
        "pcai-inference {{}}\n\
         Build: {{}} ({{}})\n\
         Commit: {{}} ({{}})\n\
         Target: {{}}\n\
         Features: {{}}\n\
         CUDA: {{}}",
        VERSION,
        BUILD_TIMESTAMP,
        BUILD_TYPE,
        GIT_HASH_SHORT,
        GIT_BRANCH,
        TARGET,
        if FEATURES.is_empty() {{ "none" }} else {{ FEATURES }},
        if HAS_CUDA {{ CUDA_VERSION }} else {{ "disabled" }}
    )
}}

/// Version info as JSON
pub fn build_info_json() -> String {{
    format!(
        r#"{{"version":"{{}}","semver":"{{}}","git_hash":"{{}}","git_branch":"{{}}","build_timestamp":"{{}}","build_type":"{{}}","target":"{{}}","profile":"{{}}","features":"{{}}","cuda_version":"{{}}","has_cuda":{{}}}}"#,
        VERSION, SEMVER, GIT_HASH, GIT_BRANCH, BUILD_TIMESTAMP, BUILD_TYPE, TARGET, PROFILE, FEATURES, CUDA_VERSION, HAS_CUDA
    )
}}
"#,
        version = version,
        semver = semver,
        git_hash = git_hash,
        git_hash_short = git_hash_short,
        git_branch = git_branch,
        build_timestamp = build_timestamp,
        build_type = build_type,
        target = target,
        profile = profile,
        features_str = features_str,
        cuda_version = cuda_version,
        has_cuda = has_cuda,
    );

    fs::write(&dest_path, content).expect("Failed to write build_info.rs");

    // Also set as rustc-env for use in code
    println!("cargo:rustc-env=PCAI_VERSION={}", version);
    println!("cargo:rustc-env=PCAI_GIT_HASH={}", git_hash);
    println!("cargo:rustc-env=PCAI_GIT_HASH_SHORT={}", git_hash_short);
    println!("cargo:rustc-env=PCAI_BUILD_TIMESTAMP={}", build_timestamp);
}

fn get_git_hash() -> String {
    Command::new("git")
        .args(["rev-parse", "HEAD"])
        .output()
        .ok()
        .and_then(|output| {
            if output.status.success() {
                String::from_utf8(output.stdout)
                    .ok()
                    .map(|s| s.trim().to_string())
            } else {
                None
            }
        })
        .unwrap_or_else(|| "unknown".to_string())
}

fn get_git_branch() -> String {
    Command::new("git")
        .args(["rev-parse", "--abbrev-ref", "HEAD"])
        .output()
        .ok()
        .and_then(|output| {
            if output.status.success() {
                String::from_utf8(output.stdout)
                    .ok()
                    .map(|s| s.trim().to_string())
            } else {
                None
            }
        })
        .unwrap_or_else(|| "unknown".to_string())
}

fn get_version_from_git() -> String {
    // Try to get version from git describe
    let describe = Command::new("git")
        .args(["describe", "--tags", "--long", "--always"])
        .output()
        .ok()
        .and_then(|output| {
            if output.status.success() {
                String::from_utf8(output.stdout)
                    .ok()
                    .map(|s| s.trim().to_string())
            } else {
                None
            }
        });

    if let Some(desc) = describe {
        // Parse: v0.1.0-5-gabcdef or just abcdef
        if desc.contains('-') {
            // Has tag info
            let parts: Vec<&str> = desc.rsplitn(3, '-').collect();
            if parts.len() >= 3 {
                let hash = parts[0].trim_start_matches('g');
                let commits = parts[1];
                let tag = parts[2].trim_start_matches('v');
                if commits == "0" {
                    format!("{}+{}", tag, hash)
                } else {
                    format!("{}.{}+{}", tag, commits, hash)
                }
            } else {
                format!("0.1.0+{}", &desc[..7.min(desc.len())])
            }
        } else {
            // Just a hash
            format!("0.1.0+{}", &desc[..7.min(desc.len())])
        }
    } else {
        "0.1.0+unknown".to_string()
    }
}

fn get_cuda_version() -> String {
    // Try nvcc --version
    Command::new("nvcc")
        .args(["--version"])
        .output()
        .ok()
        .and_then(|output| {
            if output.status.success() {
                let stdout = String::from_utf8_lossy(&output.stdout);
                // Parse: "Cuda compilation tools, release 13.1, V13.1.80"
                for line in stdout.lines() {
                    if line.contains("release") {
                        if let Some(start) = line.find("release ") {
                            let rest = &line[start + 8..];
                            if let Some(end) = rest.find(',') {
                                return Some(rest[..end].to_string());
                            }
                        }
                    }
                }
                None
            } else {
                None
            }
        })
        .unwrap_or_else(|| {
            // Fallback: check CUDA_PATH
            env::var("CUDA_PATH")
                .ok()
                .and_then(|path| {
                    // Extract version from path like "C:\...\CUDA\v13.1"
                    path.split(['\\', '/'])
                        .last()
                        .filter(|s| s.starts_with('v') || s.chars().next().map(|c| c.is_ascii_digit()).unwrap_or(false))
                        .map(|s| s.trim_start_matches('v').to_string())
                })
                .unwrap_or_else(|| "unknown".to_string())
        })
}
